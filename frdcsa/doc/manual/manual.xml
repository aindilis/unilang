<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
"file:///usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd" [
<!ENTITY legal SYSTEM "legal.xml">
]>
<book>
  <title>
    UniLang: Universal Language
  </title>
  <bookinfo>
    <author>
      <firstname>Andrew</firstname>
      <surname>Dougherty</surname>
    </author>
  </bookinfo>
  <toc>
  </toc>
  <chapter>
    <title>What is UniLang?</title>
    <sect1 id="overview">
      <title>
	Overview
      </title>
      <para>
	What is  UniLang?  UniLang is  a system that aims  to increase
	the channel  capacity, i.e. the Kolomogorov  complexity of the
	communication between the user  and the computer..  Because it
	is our object to increase the complexity of formal systems, we
	must be  able to rapidly  and accurately communicate  with our
	computer  system.   In otherwords,  we  wish  to maximize  the
	communication  channel  capacity  between  the  user  and  the
	computer.
      </para>
      <para>
	How does one maximize this  capacity?  The obvious goal is the
	mind  to  machine   interface,  where  the  computer  monitors
	measurable  aspects of  the users  brain and,  as  an example,
	knows what  they are thinking to themselves.   Because we lack
	this technology, we must find other ways.
      </para>
      <para>
	Some other  ways are that  we can compress  the communication.
	This relies on both the user and the computer knowing a common
	communication compression scheme.  For instance, with Emacs, a
	great  number  of commands  are  bound  to  quick control  key
	sequences.  In  fact, we are interested in  improving on Emacs
	key layout in order to  make it change according to key usage,
	although  since  key  usage   patterns  depend  on  the  users
	knowledge of  Emacs, a  more urgent priority  is an  ITS which
	tutors  the   user  effectively  on  the   key  sequences  and
	functions,  etc.  So,  Emacs  is an  example of  compressioned
	communication.
      </para>
      <para>
	u n i l a n <tab> <return> c d SPC m a <backspace> 
<backspace> d o <tab> <return> l s <return> C-x C-f M a <backspace> m
<backspace> <backspace> m a n u <tab> x m l <return> C-s p r o u f
<backspace> <backspace> f o u n d M-f <M-backspace> p r o f u n d i t
y M-q C-x C-s C-a C-p C-p C-u C-u C-p C-u C-u C-p C-p C-h l C-x o C-x
C-SPC C-n C-x C-g C-h l C-x o C-SPC M-> M-w C-x k RET C-x o C-h l
      </para>
      <para>
	Another compression scheme relies on the user and the computer
	sharing a high level  language which can efficiently represent
	concepts by  virtue of the profundity of  its atomic elements,
	as with opencyc-el.  Yet another scheme involves very accurate
	cognitive modelling of the user, for instance, as in the CLEAR
	project.
      </para>
      <para>
	UniLang makes use of  yet another principle for maximizing the
	communication rate.  Remember that  our purpose is to maximize
	the complexity of our  system, and the communication rate with
	the user.   In order to  do this therefore, UniLang  takes the
	approach that it should understand and act on all of the users
	comments, so that whenever an  idea is offered, it is inserted
	into  the correct  data  structures. In  otherwords, it  makes
	efficient  use of  the communication  by applying  careful and
	sophisticated reasoning to  try to establish the illocutionary
	force of the message, i.e. what the user is trying to say, and
	then ensure that, as  consistent with its understanding of the
	overall goals, it takes  various actions which follow from the
	concepts presented by the user.  In this way the system builds
	itself  up  automatically out  of  the suggestions,  comments,
	thoughts, etc of the user.
      </para>
      <para>
	For instance, if  the user says, "Oh, we  need to acquire this
	since that  depends on it",  the proposition is  asserted into
	the  planning  system.  Or  if  the user  has  an  idea for  a
	feature,  the feature  request is  routed to  the capabilities
	management system,  which searches its  archives and otherwise
	launches   a   new  search   for   systems  implementing   the
	capabilities, and the request becomes a feature in the project
	description.   So  the  job  of  UniLang is  to  redirect  the
	comments of the user to appropriate systems for handling these
	comments.  That is why it bears the name, Universal Language.
      </para>
    </sect1>
    <sect1 id="Features">
      <title>
	Features
      </title>
      <para>
	With stream  of consciousness  thinking, it is  important that
	information be  routed to an  appropriate location as  soon as
	possible,  otherwise it  will have  to simply  be  stacked for
	later analysis.   However, simply stacking  the information is
	not sufficient to ensure  a complete planning process, because
	so-called  linear planning  is incomplete,  since in  order to
	have  the ability  to  analyze such  stacks,  you require  the
	capabilities that  are mentioned, but  not implemented, within
	the  stack.   Therefore,   nonlinear  planning  is  necessary.
	UniLang  aids in  this by  routing  the information  as it  is
	arrives from the user.
      </para>
      <para>
	This is  a design shift  away from more passive  systems which
	expect  the user  to interact  according to  the needs  of one
	application, and lack the  ubiquity and pervasiveness in order
	to be  a dependable cognitive assistant.   So naturally, there
	are strong ties into other systems like Manager and CLEAR, and
	in fact,  architecturally these systems depend  on each other.
	And this  is where  UniLang comes into  play again,  since the
	same set of  protocols used for interacting with  the user are
	valid  for interacting  with other  applications.   So UniLang
	thus forms the basis of a Multi-Agent system.  Currently there
	are Perl modules which allow the user to agentify a program by
	providing  an event-based  programming  structure through  the
	Event Perl module.
      </para>
      <para>
	So, we  really need to distinguish between  the UniLang client
	and the UniLang MAS.  As a working system unilang embodies the
	"no  sooner said  than done"  philosophy,  because immediately
	statements  are  categorized   and  sent  to  the  appropriate
	systems, much like  in a MAS, although the  interlingua has no
	imposed syntax as of yet.
      </para>
      <para>
	In conclusion,  UniLang is an attempt to  speed interaction by
	providing  a   common  format  to   all  communications.   For
	instance, if you type in  a SubL expression, it will be routed
	to Cyc.   If you type  in a question,  it will be sent  to the
	best  question answering service.   If you  write down  a todo
	item, it will be entered into the apropriate plan.
      </para>
      <para>
	We have  also written a  special client called Ushell  for use
	with Emacs.   It derives from  Eshell, the Emacs  shell, which
	already  lets you  either run  shell  or Emacs  commands in  a
	convenient format.
      </para>
      <para>
	Lastly,  it  offers some  of  the  features  of a  Multi-Agent
	system.  We have agentified  many of the existing applications
	that we are developing, such  as Manager, PSE, Audience and so
	on.  From  the long term perspective, it  will become obsolete
	or be adapted  and repurposed once we are  able to acquire and
	package the industrial strength MAS systems it is based on.
      </para>
    </sect1>
    <sect1 id="cogntive">
      <title>
	Cognitive Assistance
      </title>
      <para>
	Of the planned  features, an interesting one is  the method of
	communication with the computer.   It has to be non-intrusive,
	but to be able to do  things like check that this really ought
	to be executed as mysql code, or check whether we approve of a
	given communication from Audience.
      </para>
      <para>
	Another  aspect is  to  consider  how to  inform  the user  of
	information.  It  must consider what the user  can be expected
	to know,  what their communication preferences  are, etc.  So,
	basically, it has to do cognitive modelling.
      </para>
      <para>
	As an unintentional benefit, this dialog system also satisfies
	some of  the goals  of the FAST  project, and  other projects,
	which intend to use  spoken communication, because, assuming a
	relatively error free  transcription (even not assuming, since
	it  will  automatically enter  into  a clarification  dialog),
	ordinary  natural language  is accepted  and  always correctly
	classified  (because  the  system  employs  a  combination  of
	safety checking, authentication, and clarification).
      </para>
    </sect1>
  </chapter>
  <chapter>
    <title>Agentifying a Perl Program</title>
    <sect1 id="howto">
      <title></title>
      <para>
	Here are the steps required to make an agent.

	First, copy the main agent code 
      </para>
    </sect1>
  </chapter>
</book>

